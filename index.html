<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PDF Structure Analyzer</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        line-height: 1.5;
        --panel-bg: color-mix(in srgb, canvas, canvastext 4%);
        --border-color: color-mix(in srgb, canvastext, transparent 85%);
        --accent: #1259ff;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: canvas;
        color: canvastext;
        padding: 1.5rem;
      }

      header,
      footer {
        max-width: 1200px;
        margin: 0 auto 1rem;
      }

      header h1 {
        margin-bottom: 0.25rem;
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 1.5rem;
      }

      .panel {
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        padding: 1.25rem;
        box-shadow: 0 15px 30px color-mix(in srgb, black, transparent 90%);
      }

      .panel h2 {
        margin-top: 0;
      }

      input[type='file'] {
        display: block;
        margin-bottom: 0.75rem;
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      .actions button {
        background: var(--accent);
        color: white;
        border: none;
        padding: 0.45rem 1rem;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 600;
      }

      .actions button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .hint {
        margin-top: 0;
        font-size: 0.9rem;
        color: color-mix(in srgb, canvastext, transparent 35%);
      }

      .summary p,
      .details p {
        margin: 0.2rem 0;
      }

      .page-groups {
        list-style: none;
        padding-left: 0;
        margin: 0.5rem 0 0;
        max-height: 240px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 8px;
      }

      .page-groups li {
        padding: 0.4rem 0.6rem;
        border-bottom: 1px solid var(--border-color);
        font-size: 0.95rem;
      }

      .page-groups li:last-child {
        border-bottom: none;
      }

      .page-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
        margin-bottom: 0.75rem;
      }

      .page-controls button:enabled {
        background: var(--accent);
        color: white;
        border: none;
        padding: 0.35rem 0.8rem;
        border-radius: 6px;
        cursor: pointer;
      }

      .page-controls button:disabled {
        opacity: 0.5;
      }

      .preview {
        width: 100%;
        max-width: 500px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background: white;
        display: block;
      }

      #loading {
        min-height: 1.2rem;
        font-style: italic;
      }

      @media (max-width: 720px) {
        body {
          padding: 1rem;
        }

        main {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>PDF Structure Analyzer</h1>
      <p>
        Upload a legal PDF to inspect its pagination, detect table of contents or index pages,
        and examine headers, footers, column counts, and invisible text on any page.
      </p>
    </header>

    <main>
      <section class="panel">
        <h2>1. Upload PDF</h2>
        <input type="file" id="pdfInput" accept="application/pdf" />
        <p class="hint">
          All analysis runs locally in your browser using Mozilla's pdf.js library; the document never leaves your device.
        </p>
        <div class="actions" aria-label="Document actions">
          <button id="analyzeBtn" disabled>Analyze</button>
          <button id="previewBtn" disabled>Preview</button>
          <button id="extractBtn" disabled>Extract</button>
        </div>
        <div id="loading" aria-live="polite"></div>
      </section>

      <section class="panel">
        <h2>2. Document Overview</h2>
        <div id="summary" class="summary">Load a document to view its metadata.</div>
        <div>
          <h3>Page groups</h3>
          <ul id="pageGroups" class="page-groups"></ul>
        </div>
      </section>

      <section class="panel" id="previewPanel">
        <h2>3. Page Details & Preview</h2>
        <div class="page-controls">
          <label for="pageSelect">Jump to page:</label>
          <select id="pageSelect" disabled></select>
          <button id="prevPage" disabled>Previous page</button>
          <button id="nextPage" disabled>Next page</button>
          <span id="pageIndicator"></span>
        </div>
        <div id="pageDetails" class="details">Select a page to inspect its structure.</div>
        <canvas id="pageCanvas" class="preview" aria-label="PDF page preview"></canvas>
      </section>
    </main>

    <footer>
      <p>
        Built with <a href="https://mozilla.github.io/pdf.js/" target="_blank" rel="noreferrer">pdf.js</a> to
        accelerate legal-document ingestion for knowledge bases.
      </p>
    </footer>

    <script type="module">
      import * as pdfjsLib from 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.mjs';

      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';

      const fileInput = document.getElementById('pdfInput');
      const loadingEl = document.getElementById('loading');
      const summaryEl = document.getElementById('summary');
      const pageGroupsEl = document.getElementById('pageGroups');
      const pageDetailsEl = document.getElementById('pageDetails');
      const pageSelectEl = document.getElementById('pageSelect');
      const prevButton = document.getElementById('prevPage');
      const nextButton = document.getElementById('nextPage');
      const pageIndicator = document.getElementById('pageIndicator');
      const canvas = document.getElementById('pageCanvas');
      const ctx = canvas.getContext('2d');
      const analyzeButton = document.getElementById('analyzeBtn');
      const previewButton = document.getElementById('previewBtn');
      const extractButton = document.getElementById('extractBtn');
      const previewPanel = document.getElementById('previewPanel');

      let pdfDoc = null;
      let analysis = null;
      let currentPage = 1;
      let pdfData = null;
      let pdfFileName = 'pdf-analysis';

      fileInput.addEventListener('change', handleFileSelection);
      prevButton.addEventListener('click', () => goToPage(currentPage - 1));
      nextButton.addEventListener('click', () => goToPage(currentPage + 1));
      pageSelectEl.addEventListener('change', (event) => goToPage(Number(event.target.value)));
      analyzeButton.addEventListener('click', () => runAnalysis());
      previewButton.addEventListener('click', focusPreviewPanel);
      extractButton.addEventListener('click', exportAnalysisReport);

      function setLoading(message = '') {
        loadingEl.textContent = message;
      }

      async function handleFileSelection(event) {
        const file = event.target.files?.[0];
        resetUi();
        if (!file) {
          setLoading('');
          return;
        }

        setLoading('Reading PDF…');
        pdfData = new Uint8Array(await file.arrayBuffer());
        const baseName = file.name?.replace(/\.pdf$/i, '') || 'pdf-analysis';
        pdfFileName = baseName.replace(/[^a-z0-9-_]+/gi, '-').toLowerCase() || 'pdf-analysis';
        analyzeButton.disabled = false;
        setLoading('Ready. Click Analyze to inspect the document.');
      }

      function resetUi() {
        analysis = null;
        pdfDoc = null;
        currentPage = 1;
        pdfData = null;
        pdfFileName = 'pdf-analysis';
        summaryEl.textContent = 'Load a document to view its metadata.';
        pageGroupsEl.innerHTML = '';
        pageDetailsEl.textContent = 'Select a page to inspect its structure.';
        pageSelectEl.innerHTML = '';
        pageSelectEl.disabled = true;
        prevButton.disabled = true;
        nextButton.disabled = true;
        pageIndicator.textContent = '';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        analyzeButton.disabled = true;
        previewButton.disabled = true;
        extractButton.disabled = true;
        setLoading('');
      }

      async function runAnalysis() {
        if (!pdfData) {
          setLoading('Select a PDF to analyze.');
          return;
        }

        analyzeButton.disabled = true;
        previewButton.disabled = true;
        extractButton.disabled = true;

        setLoading('Loading PDF…');
        pdfDoc = await pdfjsLib.getDocument({ data: pdfData }).promise;
        setLoading('Analyzing document structure…');
        analysis = await analyzeDocument(pdfDoc);
        setLoading('');

        renderSummary(analysis);
        renderPageGroups(analysis.groups);
        populatePageSelect(pdfDoc.numPages);
        await renderPage(1);
        renderPageDetails(1);
        previewButton.disabled = false;
        extractButton.disabled = false;
        analyzeButton.disabled = false;
      }

      function renderSummary(docAnalysis) {
        if (!docAnalysis) return;
        const tocSummary = docAnalysis.tableOfContentsPages.length
          ? `Detected on page(s): ${docAnalysis.tableOfContentsPages.join(', ')}`
          : 'Not detected';

        const groupCounts = docAnalysis.groups.reduce((acc, group) => {
          acc[group.label] = (acc[group.label] || 0) + 1;
          return acc;
        }, {});

        const groupList = Object.entries(groupCounts)
          .map(([label, count]) => `<li><strong>${label}</strong>: ${count} page(s)</li>`)
          .join('');

        summaryEl.innerHTML = `
          <p><strong>Pages:</strong> ${docAnalysis.pageCount}</p>
          <p><strong>Table of contents:</strong> ${tocSummary}</p>
          <p><strong>Index pages detected:</strong> ${docAnalysis.indexPages.length ? docAnalysis.indexPages.join(', ') : 'Not detected'}</p>
          <div>
            <p><strong>Page distribution:</strong></p>
            <ul>${groupList || '<li>No pages analyzed</li>'}</ul>
          </div>
        `;
      }

      function renderPageGroups(groups) {
        pageGroupsEl.innerHTML = groups
          .map((group) => `<li>Page ${group.page}: ${group.label}</li>`)
          .join('');
      }

      function populatePageSelect(pageCount) {
        pageSelectEl.innerHTML = Array.from({ length: pageCount })
          .map((_, index) => `<option value="${index + 1}">Page ${index + 1}</option>`)
          .join('');
        pageSelectEl.disabled = false;
        prevButton.disabled = false;
        nextButton.disabled = false;
        pageSelectEl.value = '1';
        pageIndicator.textContent = `Page 1 of ${pageCount}`;
      }

      async function goToPage(pageNumber) {
        if (!pdfDoc || pageNumber < 1 || pageNumber > pdfDoc.numPages) return;
        currentPage = pageNumber;
        pageSelectEl.value = String(pageNumber);
        pageIndicator.textContent = `Page ${pageNumber} of ${pdfDoc.numPages}`;
        renderPageDetails(pageNumber);
        await renderPage(pageNumber);
        prevButton.disabled = pageNumber === 1;
        nextButton.disabled = pageNumber === pdfDoc.numPages;
      }

      function focusPreviewPanel() {
        if (!pdfDoc) return;
        previewPanel?.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }

      async function renderPage(pageNumber) {
        const page = await pdfDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale: 1.25 });
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        const renderContext = {
          canvasContext: ctx,
          viewport,
        };

        await page.render(renderContext).promise;
      }

      function renderPageDetails(pageNumber) {
        if (!analysis) return;
        const details = analysis.pageDetails[pageNumber - 1];
        if (!details) return;

        pageDetailsEl.innerHTML = `
          <p><strong>Classification:</strong> ${details.groupLabel}</p>
          <p><strong>Detected header:</strong> ${details.headerLine || 'Not detected'}</p>
          <p><strong>Detected footer:</strong> ${details.footerLine || 'Not detected'}</p>
          <p><strong>Estimated columns:</strong> ${details.columnCount || 0}</p>
          <p><strong>Invisible text items:</strong> ${details.invisibleItems}</p>
          <p><strong>Table of contents cues:</strong> ${(details.tocEntryRatio * 100).toFixed(0)}% of lines</p>
          <p><strong>Index cues:</strong> ${details.indexEntryCount} line(s)</p>
        `;
      }

      async function analyzeDocument(pdf) {
        const summary = {
          pageCount: pdf.numPages,
          tableOfContentsPages: [],
          indexPages: [],
          groups: [],
          pageDetails: [],
        };

        for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber += 1) {
          setLoading(`Analyzing page ${pageNumber} of ${pdf.numPages}…`);
          const page = await pdf.getPage(pageNumber);
          const viewport = page.getViewport({ scale: 1 });
          const textContent = await page.getTextContent({ normalizeWhitespace: true });
          const items = textContent.items
            .filter((item) => item.str && item.str.trim())
            .map((item) => ({
              text: item.str.trim(),
              x: item.transform[4],
              y: item.transform[5],
              width: item.width ?? Math.abs(item.transform[0]),
            }));

          const details = evaluatePage(items, viewport, pageNumber);
          summary.groups.push({ page: pageNumber, label: details.groupLabel });
          summary.pageDetails.push(details);

          if (details.hasTableOfContentsHeading || details.tocEntryRatio > 0.3) {
            summary.tableOfContentsPages.push(pageNumber);
          }
          if (details.hasIndexHeading || details.indexEntryCount > 3) {
            summary.indexPages.push(pageNumber);
          }
        }

        return summary;
      }

      function evaluatePage(items, viewport, pageNumber) {
        const lines = buildLines(items);
        const pageWidth = viewport.width || 1;
        const headerLine = lines.find((line) => line.relativeY > 0.85)?.text ?? '';
        const footerLine = [...lines].reverse().find((line) => line.relativeY < 0.15)?.text ?? '';

        let tocEntryCount = 0;
        let indexEntryCount = 0;
        let hasTocHeading = false;
        let hasIndexHeading = false;

        lines.forEach((line) => {
          const lower = line.text.toLowerCase();
          if (lower.includes('table of contents') || lower === 'contents') {
            hasTocHeading = true;
          }
          if (lower.startsWith('index') || lower.includes('alphabetical index')) {
            hasIndexHeading = true;
          }

          if (looksLikeTocEntry(line.text)) tocEntryCount += 1;
          if (looksLikeIndexEntry(line.text)) indexEntryCount += 1;
        });

        const tocEntryRatio = lines.length ? tocEntryCount / lines.length : 0;
        const groupLabel = classifyPage({ tocEntryRatio, indexEntryCount, hasTocHeading, hasIndexHeading });
        const columnCount = estimateColumnCount(lines, pageWidth);
        const invisibleItems = items.filter((item) => item.width < 0.1).length;

        return {
          pageNumber,
          headerLine,
          footerLine,
          columnCount,
          invisibleItems,
          tocEntryRatio,
          indexEntryCount,
          hasTableOfContentsHeading: hasTocHeading,
          hasIndexHeading,
          groupLabel,
        };
      }

      function buildLines(items) {
        const lineMap = new Map();
        items.forEach((item) => {
          const key = Math.round(item.y / 2);
          const row = lineMap.get(key) || [];
          row.push(item);
          lineMap.set(key, row);
        });

        const lines = [...lineMap.entries()]
          .map(([key, row]) => {
            const sorted = row.sort((a, b) => a.x - b.x);
            const text = sorted.map((item) => item.text).join(' ').replace(/\s{2,}/g, ' ').trim();
            const y = key * 2;
            const minX = sorted.length ? sorted[0].x : 0;
            return { text, y, minX };
          })
          .filter((line) => line.text)
          .sort((a, b) => b.y - a.y);

        const maxY = lines[0]?.y ?? 1;
        const minY = lines[lines.length - 1]?.y ?? 0;
        const span = Math.max(maxY - minY, 1);

        return lines.map((line) => ({
          ...line,
          relativeY: (line.y - minY) / span,
        }));
      }

      function looksLikeTocEntry(line) {
        const dottedLeader = /\.{2,}/.test(line);
        const endingPageNumber = /\s\d{1,4}$/.test(line);
        const hasLetters = /[A-Za-z]/.test(line);
        return hasLetters && (dottedLeader || endingPageNumber);
      }

      function looksLikeIndexEntry(line) {
        const pattern = /^[A-Z](?:[A-Za-z\s,\-]+)?\s+\d{1,4}$/;
        return pattern.test(line.trim());
      }

      function classifyPage({ tocEntryRatio, indexEntryCount, hasTocHeading, hasIndexHeading }) {
        if (hasTocHeading || tocEntryRatio >= 0.35) {
          return 'mainly Table of contents';
        }
        if (hasIndexHeading || indexEntryCount >= 4) {
          return 'mainly index';
        }
        return 'mainly text';
      }

      function estimateColumnCount(lines, pageWidth) {
        const xPositions = lines.map((line) => line.minX).filter((x) => Number.isFinite(x));
        if (!xPositions.length || !pageWidth) return 0;
        xPositions.sort((a, b) => a - b);
        let clusters = 1;
        const threshold = pageWidth * 0.15;
        for (let i = 1; i < xPositions.length; i += 1) {
          if (Math.abs(xPositions[i] - xPositions[i - 1]) > threshold) {
            clusters += 1;
          }
        }
        return Math.min(clusters, 4);
      }

      function exportAnalysisReport() {
        if (!analysis) return;
        const markdown = buildMarkdownReport(analysis);
        const blob = new Blob([markdown], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${pdfFileName || 'pdf-analysis'}-structure.md`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      function buildMarkdownReport(docAnalysis) {
        const tocPages = docAnalysis.tableOfContentsPages.length
          ? docAnalysis.tableOfContentsPages.join(', ')
          : 'Not detected';
        const indexPages = docAnalysis.indexPages.length ? docAnalysis.indexPages.join(', ') : 'Not detected';

        let markdown = `# PDF Analysis Report\n\n`;
        markdown += `- **Pages**: ${docAnalysis.pageCount}\n`;
        markdown += `- **Table of contents**: ${tocPages}\n`;
        markdown += `- **Index pages**: ${indexPages}\n\n`;

        markdown += `## Page Groups\n`;
        docAnalysis.groups.forEach((group) => {
          markdown += `- Page ${group.page}: ${group.label}\n`;
        });

        markdown += `\n## Page Details\n`;
        docAnalysis.pageDetails.forEach((detail) => {
          markdown += `\n### Page ${detail.pageNumber}\n`;
          markdown += `- Classification: ${detail.groupLabel}\n`;
          markdown += `- Header: ${detail.headerLine || 'Not detected'}\n`;
          markdown += `- Footer: ${detail.footerLine || 'Not detected'}\n`;
          markdown += `- Estimated columns: ${detail.columnCount || 0}\n`;
          markdown += `- Invisible text items: ${detail.invisibleItems}\n`;
          markdown += `- TOC cues: ${(detail.tocEntryRatio * 100).toFixed(0)}% of lines\n`;
          markdown += `- Index cues: ${detail.indexEntryCount}\n`;
        });

        return markdown;
      }
    </script>
  </body>
</html>
